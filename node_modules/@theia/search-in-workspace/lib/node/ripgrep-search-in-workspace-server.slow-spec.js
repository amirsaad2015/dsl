"use strict";
/*
 * Copyright (C) 2017-2018 Ericsson and others.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
var chai = require("chai");
var expect = chai.expect;
var temp = require("temp");
var fs = require("fs");
var ripgrep_search_in_workspace_server_1 = require("./ripgrep-search-in-workspace-server");
var search_in_workspace_interface_1 = require("../common/search-in-workspace-interface");
var inversify_1 = require("inversify");
var core_1 = require("@theia/core");
var mock_logger_1 = require("@theia/core/lib/common/test/mock-logger");
var node_1 = require("@theia/process/lib/node");
var path = require("path");
// Allow creating temporary files, but remove them when we are done.
var track = temp.track();
// The root dir we'll use to test searching.
var rootDir;
// Remember the content of the test files we create, to validate that the
// reported line text is right.
var fileLines = new Map();
// The class under test.
var ripgrepServer;
// Mock client that accumulates the returned results in a list.
var ResultAccumulator = /** @class */ (function () {
    function ResultAccumulator(onDoneCallback) {
        this.results = [];
        this.onDoneCallback = onDoneCallback;
    }
    ResultAccumulator.prototype.onResult = function (searchId, result) {
        this.results.push(result);
    };
    ResultAccumulator.prototype.onDone = function (searchId) {
        // Sort the results, so that the order is predictable.
        this.results.sort(search_in_workspace_interface_1.SearchInWorkspaceResult.compare);
        this.onDoneCallback();
    };
    return ResultAccumulator;
}());
// Create a test file relative to rootDir.
function createTestFile(filename, text) {
    fs.writeFileSync(rootDir + '/' + filename, text);
    fileLines.set(filename, text.split('\n'));
}
before(function () {
    rootDir = track.mkdirSync();
    createTestFile('carrots', "This is a carrot.\nMost carrots are orange, but some carrots are not.\nOnce capitalized, the word carrot looks like this: CARROT.\nCarrot is a funny word.\n");
    createTestFile('potatoes', "Potatoes, unlike carrots, are generally not orange.  But sweet potatoes are,\nit's very confusing.\n");
    createTestFile('regexes', "aaa hello x h3lo y hell0h3lllo\nhello1\n");
    fs.mkdirSync(rootDir + '/small');
    createTestFile('small/small', 'A small file.\n');
    if (!core_1.isWindows) {
        createTestFile('file:with:some:colons', "Are you looking for this: --foobar?\n");
    }
    createTestFile('file with spaces', "Are you looking for this: --foobar?\n");
    createTestFile('utf8-file', "Var \u00E4r jag?  Varf\u00F6r \u00E4r jag h\u00E4r?\n");
    var lotsOfMatchesText = '';
    for (var i = 0; i < 100000; i++) {
        lotsOfMatchesText += 'lots-of-matches\n';
    }
    createTestFile('lots-of-matches', lotsOfMatchesText);
});
beforeEach(function () {
    var container = new inversify_1.Container();
    var module = new inversify_1.ContainerModule(function (bind) {
        bind(core_1.ILogger).to(mock_logger_1.MockLogger);
        bind(ripgrep_search_in_workspace_server_1.RipgrepSearchInWorkspaceServer).toSelf();
        bind(node_1.ProcessManager).toSelf().inSingletonScope();
        bind(node_1.RawProcess).toSelf().inTransientScope();
        bind(node_1.RawProcessFactory).toFactory(function (ctx) {
            return function (options) {
                var child = new inversify_1.Container({ defaultScope: 'Singleton' });
                child.parent = ctx.container;
                child.bind(node_1.RawProcessOptions).toConstantValue(options);
                return child.get(node_1.RawProcess);
            };
        });
    });
    container.load(module);
    ripgrepServer = container.get(ripgrep_search_in_workspace_server_1.RipgrepSearchInWorkspaceServer);
});
after(function () {
    track.cleanupSync();
});
// Compare expected and actual search results.
//
// For convenience, the expected entries do not have their lineText field set
// by individual tests.  Using on the file and line fields, this function
// retrieves the expected line text based on what we have written to the test
// files.
//
// The expected entries should also have the file field set relatively to
// rootDir.  This function will update the field to contain the absolute path.
function compareSearchResults(expected, actual) {
    expect(actual.length).eq(expected.length);
    if (actual.length !== expected.length) {
        return;
    }
    for (var i = 0; i < actual.length; i++) {
        var a = actual[i];
        var e = expected[i];
        var lines = fileLines.get(e.file);
        if (lines) {
            var line = lines[e.line - 1];
            e.lineText = line;
            e.file = path.join(rootDir, e.file);
            expect(a).deep.eq(e);
        }
        else {
            // We don't know this file...
            expect.fail();
        }
    }
}
describe('ripgrep-search-in-workspace-server', function () {
    this.timeout(10000);
    // Try some simple patterns with different case.
    it('returns 7 results when searching for "carrot"', function (done) {
        var pattern = 'carrot';
        var client = new ResultAccumulator(function () {
            var expected = [
                { file: 'carrots', line: 1, character: 11, length: pattern.length, lineText: '' },
                { file: 'carrots', line: 2, character: 6, length: pattern.length, lineText: '' },
                { file: 'carrots', line: 2, character: 35, length: pattern.length, lineText: '' },
                { file: 'carrots', line: 3, character: 28, length: pattern.length, lineText: '' },
                { file: 'carrots', line: 3, character: 52, length: pattern.length, lineText: '' },
                { file: 'carrots', line: 4, character: 1, length: pattern.length, lineText: '' },
                { file: 'potatoes', line: 1, character: 18, length: pattern.length, lineText: '' },
            ];
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    it('returns 1 result when searching for "Carrot"', function (done) {
        var client = new ResultAccumulator(function () {
            var expected = [
                { file: 'carrots', line: 4, character: 1, length: 6, lineText: '' },
            ];
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search('Carrot', rootDir);
    });
    it('returns 0 result when searching for "CarroT"', function (done) {
        var pattern = 'CarroT';
        var client = new ResultAccumulator(function () {
            compareSearchResults([], client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    // Try something that we know isn't there.
    it('finds 0 result when searching for "PINEAPPLE"', function (done) {
        var pattern = 'PINEAPPLE';
        var client = new ResultAccumulator(function () {
            compareSearchResults([], client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    // Try a pattern with a space.
    it('finds 1 result when searching for "carrots are orange"', function (done) {
        var pattern = 'carrots are orange';
        var client = new ResultAccumulator(function () {
            var expected = [
                { file: 'carrots', line: 2, character: 6, length: pattern.length, lineText: '' },
            ];
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    // Try with an output size that exceeds the default node buffer size
    // (200 * 1024) when spawning a new process.
    it('works with a lot of results', function (done) {
        // This can take a bit of time.
        this.timeout(150000);
        var pattern = 'lots-of-matches';
        var client = new ResultAccumulator(function () {
            var expected = [];
            for (var i = 1; i <= 100000; i++) {
                expected.push({
                    file: 'lots-of-matches',
                    line: i,
                    character: 1,
                    length: pattern.length,
                    lineText: '',
                });
            }
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    // Try limiting the number of returned results.
    it('limits the number of returned results', function (done) {
        var pattern = 'lots-of-matches';
        var client = new ResultAccumulator(function () {
            var expected = [];
            for (var i = 1; i <= 1000; i++) {
                expected.push({
                    file: 'lots-of-matches',
                    line: i,
                    character: 1,
                    length: pattern.length,
                    lineText: '',
                });
            }
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir, {
            maxResults: 1000,
        });
    });
    // Try with regexes.
    it('searches for regexes', function (done) {
        var pattern = 'h[e3]l+[o0]';
        var client = new ResultAccumulator(function () {
            var expected = [
                { file: 'regexes', line: 1, character: 5, length: 5, lineText: '' },
                { file: 'regexes', line: 1, character: 13, length: 4, lineText: '' },
                { file: 'regexes', line: 1, character: 20, length: 5, lineText: '' },
                { file: 'regexes', line: 1, character: 25, length: 6, lineText: '' },
                { file: 'regexes', line: 2, character: 1, length: 5, lineText: '' },
            ];
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    // Try with a pattern starting with -, and in filenames containing colons and spaces.
    it('searches a pattern starting with -', function (done) {
        var pattern = '-fo+bar';
        var client = new ResultAccumulator(function () {
            var expected = [
                { file: 'file with spaces', line: 1, character: 28, length: 7, lineText: '' },
            ];
            if (!core_1.isWindows) {
                expected.push({ file: 'file:with:some:colons', line: 1, character: 28, length: 7, lineText: '' });
            }
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    // Try with a pattern starting with --, and in filenames containing colons and spaces.
    it('searches a pattern starting with --', function (done) {
        var pattern = '--fo+bar';
        var client = new ResultAccumulator(function () {
            var expected = [
                { file: 'file with spaces', line: 1, character: 27, length: 8, lineText: '' },
            ];
            if (!core_1.isWindows) {
                expected.push({ file: 'file:with:some:colons', line: 1, character: 27, length: 8, lineText: '' });
            }
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    // Try searching in an UTF-8 file.
    it('searches in a UTF-8 file', function (done) {
        var pattern = ' jag';
        var client = new ResultAccumulator(function () {
            var expected = [
                { file: 'utf8-file', line: 1, character: 7, length: 4, lineText: '' },
                { file: 'utf8-file', line: 1, character: 23, length: 4, lineText: '' },
            ];
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    // Try searching a pattern that contains unicode characters.
    it('searches a UTF-8 pattern', function (done) {
        var pattern = ' h?är';
        var client = new ResultAccumulator(function () {
            var expected = [
                { file: 'utf8-file', line: 1, character: 4, length: 3, lineText: '' },
                { file: 'utf8-file', line: 1, character: 20, length: 3, lineText: '' },
                { file: 'utf8-file', line: 1, character: 27, length: 4, lineText: '' },
            ];
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir);
    });
    // A regex that may match an empty string should not return zero-length
    // results.  Run the test in a directory without big files, because it
    // makes rg print all searched lines, which can take a lot of time.
    it('doesn\'t return zero-length matches', function (done) {
        var pattern = '(hello)?';
        var client = new ResultAccumulator(function () {
            var expected = [];
            compareSearchResults(expected, client.results);
            done();
        });
        ripgrepServer.setClient(client);
        ripgrepServer.search(pattern, rootDir + '/small');
    });
});
//# sourceMappingURL=ripgrep-search-in-workspace-server.slow-spec.js.map