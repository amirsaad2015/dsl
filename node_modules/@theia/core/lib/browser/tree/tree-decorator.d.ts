import { ITree } from './tree';
import { Event, Emitter } from '../../common/event';
/**
 * Tree decorator that can change the look and the style of the tree items within a widget.
 */
export interface TreeDecorator {
    /**
     * The unique identifier of the decorator. Ought to be unique in the application.
     */
    readonly id: string;
    /**
     * Fired when this decorator has calculated all the decoration data for the tree nodes. Keys are the unique identifier of the tree nodes.
     */
    readonly onDidChangeDecorations: Event<(tree: ITree) => Map<string, TreeDecoration.Data>>;
}
/**
 * Decorator service which emits events from all known tree decorators.
 */
export declare const TreeDecoratorService: unique symbol;
export interface TreeDecoratorService {
    /**
     * Fired when any of the available tree decorators has changes. Keys are the unique tree node IDs and the values
     * are the decoration data collected from all the decorators known by this service.
     */
    readonly onDidChangeDecorations: Event<(tree: ITree) => Map<string, TreeDecoration.Data[]>>;
    /**
     * Returns with the decorators for the tree based on the actual state of this decorator service.
     */
    getDecorations(tree: ITree): Map<string, TreeDecoration.Data[]>;
    /**
     * Transforms the decorators argument into an object, so that it can be safely serialized into JSON.
     */
    deflateDecorators(decorations: Map<string, TreeDecoration.Data[]>): object;
    /**
     * Counterpart of the [deflateDecorators](#deflateDecorators) method. Restores the argument into a Map
     * of tree node IDs and the corresponding decorations data array.
     */
    inflateDecorators(state: any): Map<string, TreeDecoration.Data[]>;
}
/**
 * The default tree decorator service. Does nothing at all. One has to rebind to a concrete implementation
 * if decorators have to be supported in the tree widget.
 */
export declare class NoopTreeDecoratorService implements TreeDecoratorService {
    private emitter;
    readonly onDidChangeDecorations: Event<(tree: ITree) => Map<string, TreeDecoration.Data[]>>;
    getDecorations(): Map<any, any>;
    deflateDecorators(decorations: Map<string, TreeDecoration.Data[]>): object;
    inflateDecorators(state: any): Map<string, TreeDecoration.Data[]>;
}
/**
 * Abstract decorator service implementation which emits events from all known tree decorators and caches the current state.
 */
export declare abstract class AbstractTreeDecoratorService implements TreeDecoratorService {
    protected readonly decorators: ReadonlyArray<TreeDecorator>;
    protected readonly emitter: Emitter<(tree: ITree) => Map<string, TreeDecoration.Data[]>>;
    protected readonly decorations: Map<string, (tree: ITree) => Map<string, TreeDecoration.Data>>;
    constructor(decorators: ReadonlyArray<TreeDecorator>);
    readonly onDidChangeDecorations: Event<(tree: ITree) => Map<string, TreeDecoration.Data[]>>;
    getDecorations(tree: ITree): Map<string, TreeDecoration.Data[]>;
    deflateDecorators(decorations: Map<string, TreeDecoration.Data[]>): object;
    inflateDecorators(state: any): Map<string, TreeDecoration.Data[]>;
}
/**
 * Namespace for the decoration data and the styling refinements for the decorated tree nodes.
 */
export declare namespace TreeDecoration {
    /**
     * CSS styles for the tree decorators.
     */
    namespace Styles {
        const CAPTION_PREFIX_CLASS = "theia-caption-prefix";
        const CAPTION_SUFFIX_CLASS = "theia-caption-suffix";
        const ICON_WRAPPER_CLASS = "theia-icon-wrapper";
        const DECORATOR_SIZE_CLASS = "theia-decorator-size";
        const TOP_RIGHT_CLASS = "theia-top-right";
        const BOTTOM_RIGHT_CLASS = "theia-bottom-right";
        const BOTTOM_LEFT_CLASS = "theia-bottom-left";
        const TOP_LEFT_CLASS = "theia-top-left";
    }
    /**
     * For the sake of simplicity, we have merged the `font-style`, `font-weight`, and the `text-decoration` together.
     */
    type FontStyle = 'normal' | 'bold' | 'italic' | 'oblique' | 'underline' | 'line-through';
    /**
     * A string that could be:
     *
     *  - one of the browser colors, (E.g.: `blue`, `red`, `magenta`),
     *  - the case insensitive hexadecimal color code, (for instance, `#ee82ee`, `#20B2AA`, `#f09` ), or
     *  - either the `rgb()` or the `rgba()` functions.
     *
     * For more details, see: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value.
     *
     * Note, it is highly recommended to use one of the predefined colors of Theia, so the desired color will
     * look nice with both the `light` and the `dark` theme too.
     */
    type Color = string;
    /**
     * Encapsulates styling information of the font.
     */
    interface FontData {
        /**
         * Zero to any font style.
         */
        readonly style?: FontStyle | FontStyle[];
        /**
         * The color of the font.
         */
        readonly color?: Color;
    }
    /**
     * Arbitrary information that has to be shown either before or after the caption as a prefix or a suffix.
     */
    interface CaptionAffix {
        /**
         * The text content of the prefix or the suffix.
         */
        readonly data: string;
        /**
         * Font data for customizing the prefix of the suffix.
         */
        readonly fontData?: FontData;
    }
    /**
     * Unlike caption suffixes, tail decorations appears right-aligned after the caption and the caption suffixes (is any).
     */
    interface TailDecoration extends CaptionAffix {
        /**
         * Optional tooltip for the tail decoration.
         */
        readonly tooltip?: string;
    }
    /**
     * Enumeration for the quadrant to overlay the image on.
     */
    enum IconOverlayPosition {
        /**
         * Overlays the top right quarter of the original image.
         */
        TOP_RIGHT = 0,
        /**
         * Overlays the bottom right of the original image.
         */
        BOTTOM_RIGHT = 1,
        /**
         * Overlays the bottom left segment of the original image.
         */
        BOTTOM_LEFT = 2,
        /**
         * Occupies the top left quarter of the original icon.
         */
        TOP_LEFT = 3,
    }
    namespace IconOverlayPosition {
        /**
         * Returns with the CSS class style for the enum.
         */
        function getStyle(position: IconOverlayPosition): string;
    }
    /**
     * A shape that can be optionally rendered behind the overlay icon. Can be used to further refine colors.
     */
    interface IconOverlayBackground {
        /**
         * Either `circle` or `square`.
         */
        readonly shape: 'circle' | 'square';
        /**
         * The color of the background shape.
         */
        readonly color?: Color;
    }
    /**
     * Has not effect if the tree node being decorated has no associated icon.
     */
    interface IconOverlay {
        /**
         * The position where the decoration will be placed on the top of the original icon.
         */
        readonly position: IconOverlayPosition;
        /**
         * This should be the name of the Font Awesome icon with out the `fa fa-` prefix, just the name, for instance `paw`.
         * For the existing icons, see here: https://fontawesome.com/v4.7.0/icons/.
         */
        readonly icon: string;
        /**
         * The color of the overlaying icon. If not specified, then the default icon color will be used.
         */
        readonly color?: Color;
        /**
         * The optional background color of the overlay icon.
         */
        readonly background?: IconOverlayBackground;
    }
    /**
     * Encapsulates styling information that has to be applied on the tree node which we decorate.
     */
    interface Data {
        /**
         * The higher number has higher priority. If not specified, treated as `0`.
         * When multiple decorators are available for the same item, and decoration data cannot be merged together,
         * then the higher priority item will be applied on the decorated element and the lower priority will be ignored.
         */
        readonly priority?: number;
        /**
         * The font data for the caption.
         */
        readonly fontData?: FontData;
        /**
         * The background color of the entire row.
         */
        readonly backgroundColor?: Color;
        /**
         * Optional, leading prefixes right before the caption.
         */
        readonly captionPrefixes?: CaptionAffix[];
        /**
         * Suffixes that might come after the caption as an additional information.
         */
        readonly captionSuffixes?: CaptionAffix[];
        /**
         * Optional right-aligned decorations that appear after the node caption and after the caption suffixes (is any).
         */
        readonly tailDecorations?: TailDecoration[];
        /**
         * Custom tooltip for the decorated item. Tooltip will be appended to the original tooltip, if any.
         */
        readonly tooltip?: string;
        /**
         * Sets the color of the icon. Ignored if the decorated item has no icon.
         */
        readonly iconColor?: Color;
        /**
         * Has not effect if given, but the tree node does not have an associated image.
         */
        readonly iconOverlay?: IconOverlay;
    }
    namespace Data {
        /**
         * Compares the decoration data based on the priority. Lowest priorities come first.
         */
        const comparePriority: (left: Data, right: Data) => number;
    }
}
