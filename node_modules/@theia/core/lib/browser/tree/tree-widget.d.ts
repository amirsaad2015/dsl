import { Message } from "@phosphor/messaging";
import { h, ElementAttrs, ElementInlineStyle } from "@phosphor/virtualdom";
import { MenuPath } from "../../common";
import { ContextMenuRenderer } from "../context-menu-renderer";
import { StatefulWidget } from '../shell';
import { VirtualWidget } from "../widgets";
import { ITreeNode, ICompositeTreeNode } from "./tree";
import { ITreeModel } from "./tree-model";
import { IExpandableTreeNode } from "./tree-expansion";
import { TreeDecoration, TreeDecoratorService } from "./tree-decorator";
export declare const TREE_CLASS = "theia-Tree";
export declare const TREE_NODE_CLASS = "theia-TreeNode";
export declare const TREE_NODE_TAIL_CLASS = "theia-TreeNodeTail";
export declare const TREE_NODE_SEGMENT_CLASS = "theia-TreeNodeSegment";
export declare const TREE_NODE_SEGMENT_GROW_CLASS = "theia-TreeNodeSegmentGrow";
export declare const EXPANDABLE_TREE_NODE_CLASS = "theia-ExpandableTreeNode";
export declare const COMPOSITE_TREE_NODE_CLASS = "theia-CompositeTreeNode";
export declare const TREE_NODE_CAPTION_CLASS = "theia-TreeNodeCaption";
export declare const EXPANSION_TOGGLE_CLASS = "theia-ExpansionToggle";
export declare const TreeProps: unique symbol;
export interface TreeProps {
    /**
     * The path of the context menu that one can use to contribute context menu items to the tree widget.
     */
    readonly contextMenuPath?: MenuPath;
    /**
     * The size of the padding (in pixels) per hierarchy depth. The root element won't have left padding but
     * the padding for the children will be calculated as `leftPadding * hierarchyDepth` and so on.
     */
    readonly leftPadding: number;
}
export interface NodeProps {
    /**
     * A root relative number representing the hierarchical depth of the actual node. Root is `0`, its children have `1` and so on.
     */
    readonly depth: number;
    /**
     * Tests whether the node should be rendered as hidden.
     *
     * It is different from visibility of a node: an invisible node is not rendered at all.
     */
    readonly visible: boolean;
}
export declare const defaultTreeProps: TreeProps;
export declare class TreeWidget extends VirtualWidget implements StatefulWidget {
    readonly props: TreeProps;
    readonly model: ITreeModel;
    protected readonly contextMenuRenderer: ContextMenuRenderer;
    protected readonly decoratorService: TreeDecoratorService;
    protected decorations: Map<string, TreeDecoration.Data[]>;
    constructor(props: TreeProps, model: ITreeModel, contextMenuRenderer: ContextMenuRenderer);
    protected init(): void;
    protected updateDecorations(decorations: Map<string, TreeDecoration.Data[]>): void;
    protected onActivateRequest(msg: Message): void;
    protected onUpdateRequest(msg: Message): void;
    protected render(): h.Child;
    protected renderTree(model: ITreeModel): h.Child;
    protected createRootProps(node: ITreeNode): NodeProps;
    protected renderSubTree(node: ITreeNode, props: NodeProps): h.Child;
    protected renderIcon(node: ITreeNode, props: NodeProps): h.Child;
    protected renderExpansionToggle(node: ITreeNode, props: NodeProps): h.Child;
    protected renderCaption(node: ITreeNode, props: NodeProps): h.Child;
    protected decorateCaption(node: ITreeNode, attrs: ElementAttrs): ElementAttrs;
    protected hasTrailingSuffixes(node: ITreeNode): boolean;
    protected applyFontStyles(original: ElementInlineStyle, fontData: TreeDecoration.FontData | undefined): ElementInlineStyle;
    protected renderCaptionAffixes(node: ITreeNode, props: NodeProps, affixKey: 'captionPrefixes' | 'captionSuffixes'): h.Child[];
    protected decorateIcon(node: ITreeNode, icon: h.Child | null): h.Child;
    protected renderTailDecorations(node: ITreeNode, props: NodeProps): h.Child[];
    protected renderNode(node: ITreeNode, props: NodeProps): h.Child;
    protected createNodeAttributes(node: ITreeNode, props: NodeProps): ElementAttrs;
    protected createNodeClassNames(node: ITreeNode, props: NodeProps): string[];
    protected getDefaultNodeStyle(node: ITreeNode, props: NodeProps): ElementInlineStyle | undefined;
    protected createNodeStyle(node: ITreeNode, props: NodeProps): ElementInlineStyle | undefined;
    protected decorateNodeStyle(node: ITreeNode, style: ElementInlineStyle | undefined): ElementInlineStyle | undefined;
    protected isExpandable(node: ITreeNode): node is IExpandableTreeNode;
    protected renderNodeChildren(node: ITreeNode, props: NodeProps): h.Child;
    protected renderCompositeChildren(parent: ICompositeTreeNode, props: NodeProps): h.Child;
    protected renderChild(child: ITreeNode, parent: ICompositeTreeNode, props: NodeProps): h.Child;
    protected createChildProps(child: ITreeNode, parent: ICompositeTreeNode, props: NodeProps): NodeProps;
    protected createExpandableChildProps(child: ITreeNode, parent: IExpandableTreeNode, props: NodeProps): NodeProps;
    protected getDecorations(node: ITreeNode): TreeDecoration.Data[];
    protected getDecorationData<K extends keyof TreeDecoration.Data>(node: ITreeNode, key: K): TreeDecoration.Data[K][];
    protected onAfterAttach(msg: Message): void;
    protected handleLeft(): void;
    protected handleRight(): void;
    protected handleUp(): void;
    protected handleDown(): void;
    protected handleEnter(): void;
    protected handleClickEvent(node: ITreeNode | undefined, event: MouseEvent): void;
    protected handleDblClickEvent(node: ITreeNode | undefined, event: MouseEvent): void;
    protected handleContextMenuEvent(node: ITreeNode | undefined, event: MouseEvent): void;
    protected deflateForStorage(node: ITreeNode): object;
    protected inflateFromStorage(node: any, parent?: ITreeNode): ITreeNode;
    storeState(): object;
    restoreState(oldState: object): void;
}
