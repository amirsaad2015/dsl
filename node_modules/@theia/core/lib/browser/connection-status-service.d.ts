import { ILogger } from '../common/logger';
import { Event, Emitter } from '../common/event';
import { FrontendApplicationContribution, DefaultFrontendApplicationContribution } from './frontend-application';
import { StatusBar } from './status-bar/status-bar';
/**
 * Service for listening on backend connection changes.
 */
export declare const ConnectionStatusService: unique symbol;
export interface ConnectionStatusService {
    /**
     * The actual connection state.
     */
    readonly currentState: ConnectionStatus;
    /**
     * Clients can listen on connection status change events.
     */
    readonly onStatusChange: Event<ConnectionStatus>;
}
/**
 * Connection status change event.
 */
export interface ConnectionStatus {
    /**
     * The current state of the connection.
     */
    readonly state: ConnectionState;
}
/**
 * The connection-status states.
 */
export declare enum ConnectionState {
    /**
     * Connected to the backend.
     */
    ONLINE = 0,
    /**
     * The connection is lost between the client and the endpoint.
     */
    OFFLINE = 1,
    /**
     * Initially we don't know whether we are online or offline.
     */
    INITIAL = 2,
}
export declare class ConnectionStatusOptions {
    static DEFAULT: ConnectionStatusOptions;
    /**
     * Number of accepted timeouts. Must be a positive integer.
     */
    readonly retry: number;
    /**
     * Retry interval in milliseconds. Must be a positive integer.
     */
    readonly retryInterval: number;
    /**
     * The maximum retry interval in milliseconds. Should be a positive integer.
     *
     * If the request is timing out because of the slow Internet connection or the server is overloaded, we increase the `retryInterval` until it reaches this `maxRetryInterval`.
     */
    readonly maxRetryInterval: number;
    /**
     * Timeout for the HTTP GET request in milliseconds. Must be a positive integer.
     */
    readonly requestTimeout: number;
}
export declare class FrontendConnectionStatusService implements ConnectionStatusService, FrontendApplicationContribution {
    protected readonly options: ConnectionStatusOptions;
    protected readonly logger: ILogger;
    protected readonly statusChangeEmitter: Emitter<ConnectionStatus>;
    protected readonly endpointUrl: string;
    protected connectionState: ConnectionStatusImpl;
    protected timer: number | undefined;
    protected retryInterval: number;
    constructor(options: ConnectionStatusOptions, logger: ILogger);
    onStart(): void;
    onStop(): void;
    start(): void;
    stop(): void;
    readonly onStatusChange: Event<ConnectionStatus>;
    readonly currentState: ConnectionStatusImpl;
    protected schedule(checkAlive: () => Promise<boolean>): void;
    protected updateStatus(success: boolean): ConnectionStatusImpl;
    protected fireStatusChange(event: ConnectionStatus): void;
    protected checkAlive(): Promise<boolean>;
    protected setTimeout(handler: (...args: any[]) => void, timeout: number): number;
    protected clearTimeout(handle: number): void;
}
export declare class ApplicationConnectionStatusContribution extends DefaultFrontendApplicationContribution {
    protected readonly connectionStatusService: ConnectionStatusService;
    protected readonly statusBar: StatusBar;
    protected readonly logger: ILogger;
    constructor(connectionStatusService: ConnectionStatusService, statusBar: StatusBar, logger: ILogger);
    protected onStatusChange(status: ConnectionStatus): void;
    private statusbarId;
    protected handleOnline(): void;
    protected handleOffline(): void;
}
export declare class ConnectionStatusImpl implements ConnectionStatus {
    protected readonly props: {
        readonly threshold: number;
    };
    readonly state: ConnectionState;
    protected readonly history: boolean[];
    private static readonly MAX_HISTORY;
    constructor(props: {
        readonly threshold: number;
    }, state?: ConnectionState, history?: boolean[]);
    next(success: boolean): ConnectionStatusImpl;
    protected updateHistory(success: boolean): boolean[];
}
