import { CommandRegistry } from '../common/command';
import { KeySequence } from './keys';
import { ContributionProvider } from '../common/contribution-provider';
import { ILogger } from "../common/logger";
import { StatusBar } from './status-bar/status-bar';
export declare enum KeybindingScope {
    DEFAULT = 0,
    USER = 1,
    WORKSPACE = 2,
    END = 3,
}
export declare namespace KeybindingScope {
    const length: number;
}
export interface KeybindingsResult {
    full: Keybinding[];
    partial: Keybinding[];
    shadow: Keybinding[];
}
export declare namespace Keybinding {
    /**
     * Returns with the string representation of the binding.
     * Any additional properties which are not described on
     * the `Keybinding` API will be ignored.
     *
     * @param binding the binding to stringify.
     */
    function stringify(binding: Keybinding): string;
    function acceleratorFor(keybinding: Keybinding): string[];
}
export interface Keybinding {
    command: string;
    keybinding: string;
    /**
     * The optional keybinding context where this binding belongs to.
     * If not specified, then this keybinding context belongs to the NOOP
     * keybinding context.
     */
    context?: string;
}
export declare const KeybindingContribution: unique symbol;
export interface KeybindingContribution {
    registerKeybindings(keybindings: KeybindingRegistry): void;
}
export declare const KeybindingContext: unique symbol;
export interface KeybindingContext {
    /**
     * The unique ID of the current context.
     */
    readonly id: string;
    isEnabled(arg: Keybinding): boolean;
}
export declare namespace KeybindingContexts {
    const NOOP_CONTEXT: KeybindingContext;
    const DEFAULT_CONTEXT: KeybindingContext;
}
export declare class KeybindingRegistry {
    static readonly PASSTHROUGH_PSEUDO_COMMAND: string;
    protected keySequence: KeySequence;
    protected readonly contexts: {
        [id: string]: KeybindingContext;
    };
    protected readonly keymaps: Keybinding[][];
    protected readonly contextProvider: ContributionProvider<KeybindingContext>;
    protected readonly commandRegistry: CommandRegistry;
    protected readonly contributions: ContributionProvider<KeybindingContribution>;
    protected readonly statusBar: StatusBar;
    protected readonly logger: ILogger;
    onStart(): void;
    /**
     * Registers the keybinding context arguments into the application. Fails when an already registered
     * context is being registered.
     *
     * @param contexts the keybinding contexts to register into the application.
     */
    protected registerContext(...contexts: KeybindingContext[]): void;
    registerKeybindings(...bindings: Keybinding[]): void;
    /**
     * Register a default keybinding to the registry.
     *
     * @param binding
     */
    registerKeybinding(binding: Keybinding): void;
    /**
     * Get the keybindings associated to commandId.
     *
     * @param commandId The ID of the command for which we are looking for keybindings.
     */
    getKeybindingsForCommand(commandId: string): Keybinding[];
    /**
     * Get the lists of keybindings matching fully or partially matching a KeySequence.
     * The lists are sorted by priority (see #sortKeybindingsByPriority).
     *
     * @param keySequence The key sequence for which we are looking for keybindings.
     */
    getKeybindingsForKeySequence(keySequence: KeySequence): KeybindingsResult;
    /**
     * Returns a list of keybindings for a command in a specific scope
     * @param scope specific scope to look for
     * @param commandId unique id of the command
     */
    getScopedKeybindingsForCommand(scope: KeybindingScope, commandId: string): Keybinding[];
    /**
     * Returns true if a keybinding is shadowed in a more specific scope i.e bound in user scope but remapped in
     * workspace scope means the user keybinding is shadowed.
     * @param scope scope of the current keybinding
     * @param binding keybinding that will be checked in more specific scopes
     */
    isKeybindingShadowed(scope: KeybindingScope, binding: Keybinding): boolean;
    /**
     * Sort keybindings in-place, in order of priority.
     *
     * The only criterion right now is that a keybinding with a context has
     * more priority than a keybinding with no context.
     *
     * @param keybindings Array of keybindings to be sorted in-place.
     */
    private sortKeybindingsByPriority(keybindings);
    protected isActive(binding: Keybinding): boolean;
    protected tryKeybindingExecution(bindings: Keybinding[], event: KeyboardEvent): boolean;
    /**
     * Run the command matching to the given keyboard event.
     */
    run(event: KeyboardEvent): void;
    isPseudoCommand(commandId: string): boolean;
    setKeymap(scope: KeybindingScope, keybindings: Keybinding[]): void;
    /**
     * Reset keybindings for a specific scope
     * @param scope scope to reset the keybindings for
     */
    resetKeybindingsForScope(scope: KeybindingScope): void;
    /**
     * Reset keybindings for all scopes(only leaves the default keybindings mapped)
     */
    resetKeybindings(): void;
}
