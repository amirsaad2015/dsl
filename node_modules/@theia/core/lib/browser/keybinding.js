"use strict";
/*
 * Copyright (C) 2017 TypeFox and others.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var command_1 = require("../common/command");
var keys_1 = require("./keys");
var contribution_provider_1 = require("../common/contribution-provider");
var logger_1 = require("../common/logger");
var status_bar_1 = require("./status-bar/status-bar");
var KeybindingScope;
(function (KeybindingScope) {
    KeybindingScope[KeybindingScope["DEFAULT"] = 0] = "DEFAULT";
    KeybindingScope[KeybindingScope["USER"] = 1] = "USER";
    KeybindingScope[KeybindingScope["WORKSPACE"] = 2] = "WORKSPACE";
    KeybindingScope[KeybindingScope["END"] = 3] = "END";
})(KeybindingScope = exports.KeybindingScope || (exports.KeybindingScope = {}));
(function (KeybindingScope) {
    KeybindingScope.length = KeybindingScope.END - KeybindingScope.DEFAULT;
})(KeybindingScope = exports.KeybindingScope || (exports.KeybindingScope = {}));
var Keybinding;
(function (Keybinding) {
    /**
     * Returns with the string representation of the binding.
     * Any additional properties which are not described on
     * the `Keybinding` API will be ignored.
     *
     * @param binding the binding to stringify.
     */
    function stringify(binding) {
        var copy = {
            command: binding.command,
            keybinding: binding.keybinding,
            context: binding.context
        };
        return JSON.stringify(copy);
    }
    Keybinding.stringify = stringify;
    /* Return a user visble representation of a keybinding.  */
    function acceleratorFor(keybinding) {
        var keyCodesString = keybinding.keybinding.split(" ");
        return keys_1.KeySequence.acceleratorFor(keyCodesString.map(function (k) { return keys_1.KeyCode.parse(k); }));
    }
    Keybinding.acceleratorFor = acceleratorFor;
})(Keybinding = exports.Keybinding || (exports.Keybinding = {}));
exports.KeybindingContribution = Symbol("KeybindingContribution");
exports.KeybindingContext = Symbol("KeybindingContext");
var KeybindingContexts;
(function (KeybindingContexts) {
    KeybindingContexts.NOOP_CONTEXT = {
        id: 'noop.keybinding.context',
        isEnabled: function () { return true; }
    };
    KeybindingContexts.DEFAULT_CONTEXT = {
        id: 'default.keybinding.context',
        isEnabled: function () { return false; }
    };
})(KeybindingContexts = exports.KeybindingContexts || (exports.KeybindingContexts = {}));
var KeybindingRegistry = /** @class */ (function () {
    function KeybindingRegistry() {
        this.keySequence = [];
        this.contexts = {};
        this.keymaps = __spread(Array(KeybindingScope.length)).map(function () { return []; });
    }
    KeybindingRegistry_1 = KeybindingRegistry;
    KeybindingRegistry.prototype.onStart = function () {
        this.registerContext(KeybindingContexts.NOOP_CONTEXT);
        this.registerContext(KeybindingContexts.DEFAULT_CONTEXT);
        this.registerContext.apply(this, __spread(this.contextProvider.getContributions()));
        try {
            for (var _a = __values(this.contributions.getContributions()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var contribution = _b.value;
                contribution.registerKeybindings(this);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var e_1, _c;
    };
    /**
     * Registers the keybinding context arguments into the application. Fails when an already registered
     * context is being registered.
     *
     * @param contexts the keybinding contexts to register into the application.
     */
    KeybindingRegistry.prototype.registerContext = function () {
        var contexts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            contexts[_i] = arguments[_i];
        }
        try {
            for (var contexts_1 = __values(contexts), contexts_1_1 = contexts_1.next(); !contexts_1_1.done; contexts_1_1 = contexts_1.next()) {
                var context_1 = contexts_1_1.value;
                var id = context_1.id;
                if (this.contexts[id]) {
                    console.error("A keybinding context with ID " + id + " is already registered.");
                }
                else {
                    this.contexts[id] = context_1;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (contexts_1_1 && !contexts_1_1.done && (_a = contexts_1.return)) _a.call(contexts_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var e_2, _a;
    };
    KeybindingRegistry.prototype.registerKeybindings = function () {
        var bindings = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            bindings[_i] = arguments[_i];
        }
        try {
            for (var bindings_1 = __values(bindings), bindings_1_1 = bindings_1.next(); !bindings_1_1.done; bindings_1_1 = bindings_1.next()) {
                var binding = bindings_1_1.value;
                this.registerKeybinding(binding);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (bindings_1_1 && !bindings_1_1.done && (_a = bindings_1.return)) _a.call(bindings_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var e_3, _a;
    };
    /**
     * Register a default keybinding to the registry.
     *
     * @param binding
     */
    KeybindingRegistry.prototype.registerKeybinding = function (binding) {
        try {
            var existingBindings = this.getKeybindingsForKeySequence(keys_1.KeySequence.parse(binding.keybinding));
            if (existingBindings.full.length > 0) {
                var collided = existingBindings.full.filter(function (b) { return b.context === binding.context; });
                if (collided.length > 0) {
                    this.logger.warn('Collided keybinding is ignored; ', Keybinding.stringify(binding), ' collided with ', collided.map(function (b) { return Keybinding.stringify(b); }).join(', '));
                    return;
                }
            }
            if (existingBindings.partial.length > 0) {
                var shadows = existingBindings.partial.filter(function (b) { return b.context === binding.context; });
                if (shadows.length > 0) {
                    this.logger.warn('Shadowing keybinding is ignored; ', Keybinding.stringify(binding), ' shadows ', shadows.map(function (b) { return Keybinding.stringify(b); }).join(', '));
                    return;
                }
            }
            if (existingBindings.shadow.length > 0) {
                var shadows = existingBindings.shadow.filter(function (b) { return b.context === binding.context; });
                if (shadows.length > 0) {
                    this.logger.warn('Shadowed keybinding is ignored; ', Keybinding.stringify(binding), ' would be shadowed by ', shadows.map(function (b) { return Keybinding.stringify(b); }).join(', '));
                    return;
                }
            }
            this.keymaps[KeybindingScope.DEFAULT].push(binding);
        }
        catch (error) {
            this.logger.warn("Could not register keybinding " + Keybinding.stringify(binding));
        }
    };
    /**
     * Get the keybindings associated to commandId.
     *
     * @param commandId The ID of the command for which we are looking for keybindings.
     */
    KeybindingRegistry.prototype.getKeybindingsForCommand = function (commandId) {
        var _this = this;
        var result = [];
        for (var scope = KeybindingScope.END - 1; scope >= KeybindingScope.DEFAULT; scope--) {
            this.keymaps[scope].forEach(function (binding) {
                var command = _this.commandRegistry.getCommand(binding.command);
                if (command) {
                    if (command.id === commandId) {
                        result.push(binding);
                    }
                }
            });
            if (result.length > 0) {
                return result;
            }
        }
        return result;
    };
    /**
     * Get the lists of keybindings matching fully or partially matching a KeySequence.
     * The lists are sorted by priority (see #sortKeybindingsByPriority).
     *
     * @param keySequence The key sequence for which we are looking for keybindings.
     */
    KeybindingRegistry.prototype.getKeybindingsForKeySequence = function (keySequence) {
        var _this = this;
        var result = { full: [], partial: [], shadow: [] };
        var _loop_1 = function (scope) {
            this_1.keymaps[scope].forEach(function (binding) {
                try {
                    var bindingKeySequence = keys_1.KeySequence.parse(binding.keybinding);
                    var compareResult = keys_1.KeySequence.compare(keySequence, bindingKeySequence);
                    switch (compareResult) {
                        case keys_1.KeySequence.CompareResult.FULL: {
                            if (!_this.isKeybindingShadowed(scope, binding)) {
                                result.full.push(binding);
                            }
                            break;
                        }
                        case keys_1.KeySequence.CompareResult.PARTIAL: {
                            if (!_this.isKeybindingShadowed(scope, binding)) {
                                result.partial.push(binding);
                            }
                            break;
                        }
                        case keys_1.KeySequence.CompareResult.SHADOW: {
                            result.shadow.push(binding);
                            break;
                        }
                        default: {
                            break;
                        }
                    }
                }
                catch (error) {
                    _this.logger.warn(error);
                }
            });
        };
        var this_1 = this;
        for (var scope = KeybindingScope.DEFAULT; scope < KeybindingScope.END; scope++) {
            _loop_1(scope);
        }
        this.sortKeybindingsByPriority(result.full);
        this.sortKeybindingsByPriority(result.partial);
        return result;
    };
    /**
     * Returns a list of keybindings for a command in a specific scope
     * @param scope specific scope to look for
     * @param commandId unique id of the command
     */
    KeybindingRegistry.prototype.getScopedKeybindingsForCommand = function (scope, commandId) {
        var _this = this;
        var result = [];
        if (scope >= KeybindingScope.END) {
            return [];
        }
        this.keymaps[scope].forEach(function (binding) {
            var command = _this.commandRegistry.getCommand(binding.command);
            if (command && command.id === commandId) {
                result.push(binding);
            }
        });
        return result;
    };
    /**
     * Returns true if a keybinding is shadowed in a more specific scope i.e bound in user scope but remapped in
     * workspace scope means the user keybinding is shadowed.
     * @param scope scope of the current keybinding
     * @param binding keybinding that will be checked in more specific scopes
     */
    KeybindingRegistry.prototype.isKeybindingShadowed = function (scope, binding) {
        if (scope >= KeybindingScope.END) {
            return false;
        }
        var nextScope = ++scope;
        if (this.getScopedKeybindingsForCommand(nextScope, binding.command).length > 0) {
            return true;
        }
        return this.isKeybindingShadowed(nextScope, binding);
    };
    /**
     * Sort keybindings in-place, in order of priority.
     *
     * The only criterion right now is that a keybinding with a context has
     * more priority than a keybinding with no context.
     *
     * @param keybindings Array of keybindings to be sorted in-place.
     */
    KeybindingRegistry.prototype.sortKeybindingsByPriority = function (keybindings) {
        var _this = this;
        keybindings.sort(function (a, b) {
            var acontext;
            if (a.context) {
                acontext = _this.contexts[a.context];
            }
            var bcontext;
            if (b.context) {
                bcontext = _this.contexts[b.context];
            }
            if (acontext && !bcontext) {
                return -1;
            }
            if (!acontext && bcontext) {
                return 1;
            }
            return 0;
        });
    };
    KeybindingRegistry.prototype.isActive = function (binding) {
        /* Pseudo commands like "passthrough" are always active (and not found
           in the command registry).  */
        if (this.isPseudoCommand(binding.command)) {
            return true;
        }
        var command = this.commandRegistry.getCommand(binding.command);
        return !!command && !!this.commandRegistry.getActiveHandler(command.id);
    };
    /* Tries to execute a keybinding.
     * @param bindings list of matching keybindings as returned by getKeybindingsForKeySequence.full
     * @param event keyboard event.
     * @return true if the corresponding command was executed false otherwise.
     */
    KeybindingRegistry.prototype.tryKeybindingExecution = function (bindings, event) {
        if (bindings.length === 0) {
            return false;
        }
        try {
            for (var bindings_2 = __values(bindings), bindings_2_1 = bindings_2.next(); !bindings_2_1.done; bindings_2_1 = bindings_2.next()) {
                var binding = bindings_2_1.value;
                var context_2 = binding.context !== undefined && this.contexts[binding.context];
                /* Only execute if it has no context (global context) or if we're in
                   that context.  */
                if (!context_2 || context_2.isEnabled(binding)) {
                    if (this.isPseudoCommand(binding.command)) {
                        /* Don't do anything, let the event propagate.  */
                        return true;
                    }
                    else {
                        var command = this.commandRegistry.getCommand(binding.command);
                        if (command) {
                            var commandHandler = this.commandRegistry.getActiveHandler(command.id);
                            if (commandHandler) {
                                commandHandler.execute();
                            }
                            /* Note that if a keybinding is in context but the command is
                               not active we still stop the processing here.  */
                            event.preventDefault();
                            event.stopPropagation();
                            return true;
                        }
                    }
                    return false;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (bindings_2_1 && !bindings_2_1.done && (_a = bindings_2.return)) _a.call(bindings_2);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return false;
        var e_4, _a;
    };
    /**
     * Run the command matching to the given keyboard event.
     */
    KeybindingRegistry.prototype.run = function (event) {
        if (event.defaultPrevented) {
            return;
        }
        var keyCode = keys_1.KeyCode.createKeyCode(event);
        /* Keycode is only a modifier, next keycode will be modifier + key.
           Ignore this one.  */
        if (keyCode.isModifierOnly()) {
            return;
        }
        this.keySequence.push(keyCode);
        var bindings = this.getKeybindingsForKeySequence(this.keySequence);
        if (this.tryKeybindingExecution(bindings.full, event)) {
            this.keySequence = [];
            this.statusBar.removeElement('keybinding-status');
        }
        else if (bindings.partial.length > 0) {
            /* Accumulate the keysequence */
            event.preventDefault();
            event.stopPropagation();
            this.statusBar.setElement('keybinding-status', {
                text: "(" + keys_1.KeySequence.acceleratorFor(this.keySequence, "+") + ") was pressed, waiting for more keys",
                alignment: status_bar_1.StatusBarAlignment.LEFT,
                priority: 2
            });
        }
        else {
            this.keySequence = [];
            this.statusBar.removeElement('keybinding-status');
        }
    };
    /* Return true of string a pseudo-command id, in other words a command id
       that has a special meaning and that we won't find in the command
       registry.  */
    KeybindingRegistry.prototype.isPseudoCommand = function (commandId) {
        return commandId === KeybindingRegistry_1.PASSTHROUGH_PSEUDO_COMMAND;
    };
    KeybindingRegistry.prototype.setKeymap = function (scope, keybindings) {
        var customBindings = [];
        try {
            for (var keybindings_1 = __values(keybindings), keybindings_1_1 = keybindings_1.next(); !keybindings_1_1.done; keybindings_1_1 = keybindings_1.next()) {
                var keybinding = keybindings_1_1.value;
                try {
                    // This will throw if the keybinding is invalid.
                    keys_1.KeyCode.parse(keybinding.keybinding);
                    customBindings.push(keybinding);
                }
                catch (error) {
                    this.logger.warn("Invalid keybinding, keymap reset");
                    this.resetKeybindingsForScope(scope);
                    return;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (keybindings_1_1 && !keybindings_1_1.done && (_a = keybindings_1.return)) _a.call(keybindings_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        this.keymaps[scope] = customBindings;
        var e_5, _a;
    };
    /**
     * Reset keybindings for a specific scope
     * @param scope scope to reset the keybindings for
     */
    KeybindingRegistry.prototype.resetKeybindingsForScope = function (scope) {
        this.keymaps[scope] = [];
    };
    /**
     * Reset keybindings for all scopes(only leaves the default keybindings mapped)
     */
    KeybindingRegistry.prototype.resetKeybindings = function () {
        for (var i = KeybindingScope.DEFAULT + 1; i < KeybindingScope.END; i++) {
            this.keymaps[i] = [];
        }
    };
    KeybindingRegistry.PASSTHROUGH_PSEUDO_COMMAND = "passthrough";
    __decorate([
        inversify_1.inject(contribution_provider_1.ContributionProvider), inversify_1.named(exports.KeybindingContext),
        __metadata("design:type", Object)
    ], KeybindingRegistry.prototype, "contextProvider", void 0);
    __decorate([
        inversify_1.inject(command_1.CommandRegistry),
        __metadata("design:type", command_1.CommandRegistry)
    ], KeybindingRegistry.prototype, "commandRegistry", void 0);
    __decorate([
        inversify_1.inject(contribution_provider_1.ContributionProvider), inversify_1.named(exports.KeybindingContribution),
        __metadata("design:type", Object)
    ], KeybindingRegistry.prototype, "contributions", void 0);
    __decorate([
        inversify_1.inject(status_bar_1.StatusBar),
        __metadata("design:type", Object)
    ], KeybindingRegistry.prototype, "statusBar", void 0);
    __decorate([
        inversify_1.inject(logger_1.ILogger),
        __metadata("design:type", Object)
    ], KeybindingRegistry.prototype, "logger", void 0);
    KeybindingRegistry = KeybindingRegistry_1 = __decorate([
        inversify_1.injectable()
    ], KeybindingRegistry);
    return KeybindingRegistry;
    var KeybindingRegistry_1;
}());
exports.KeybindingRegistry = KeybindingRegistry;
//# sourceMappingURL=keybinding.js.map