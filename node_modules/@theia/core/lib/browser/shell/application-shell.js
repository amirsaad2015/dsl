"use strict";
/*
 * Copyright (C) 2018 TypeFox and others.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var algorithm_1 = require("@phosphor/algorithm");
var signaling_1 = require("@phosphor/signaling");
var widgets_1 = require("@phosphor/widgets");
var saveable_1 = require("../saveable");
var status_bar_1 = require("../status-bar/status-bar");
var side_panel_handler_1 = require("./side-panel-handler");
var tab_bars_1 = require("./tab-bars");
var split_panels_1 = require("./split-panels");
/** The class name added to ApplicationShell instances. */
var APPLICATION_SHELL_CLASS = 'theia-ApplicationShell';
/** The class name added to the main and bottom area panels. */
var MAIN_BOTTOM_AREA_CLASS = 'theia-app-centers';
exports.ApplicationShellOptions = Symbol('ApplicationShellOptions');
/**
 * A renderer for dock panels that supports context menus on tabs.
 */
var DockPanelRenderer = /** @class */ (function () {
    function DockPanelRenderer(tabBarRendererFactory) {
        this.tabBarRendererFactory = tabBarRendererFactory;
    }
    DockPanelRenderer.prototype.createTabBar = function () {
        var renderer = this.tabBarRendererFactory();
        var tabBar = new tab_bars_1.ScrollableTabBar({
            renderer: renderer,
            // Scroll bar options
            handlers: ['drag-thumb', 'keyboard', 'wheel', 'touch'],
            useBothWheelAxes: true,
            scrollXMarginOffset: 4,
            suppressScrollY: true
        });
        tabBar.addClass(MAIN_BOTTOM_AREA_CLASS);
        renderer.tabBar = tabBar;
        renderer.contextMenuPath = tab_bars_1.SHELL_TABBAR_CONTEXT_MENU;
        tabBar.currentChanged.connect(this.onCurrentTabChanged, this);
        return tabBar;
    };
    DockPanelRenderer.prototype.createHandle = function () {
        return widgets_1.DockPanel.defaultRenderer.createHandle();
    };
    DockPanelRenderer.prototype.onCurrentTabChanged = function (sender, _a) {
        var currentIndex = _a.currentIndex;
        if (currentIndex >= 0) {
            sender.revealTab(currentIndex);
        }
    };
    DockPanelRenderer = __decorate([
        inversify_1.injectable(),
        __param(0, inversify_1.inject(tab_bars_1.TabBarRendererFactory)),
        __metadata("design:paramtypes", [Function])
    ], DockPanelRenderer);
    return DockPanelRenderer;
}());
exports.DockPanelRenderer = DockPanelRenderer;
/**
 * The application shell manages the top-level widgets of the application. Use this class to
 * add, remove, or activate a widget.
 */
var ApplicationShell = /** @class */ (function (_super) {
    __extends(ApplicationShell, _super);
    /**
     * Construct a new application shell.
     */
    function ApplicationShell(dockPanelRenderer, statusBar, sidePanelHandlerFactory, splitPositionHandler, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, options) || this;
        _this.dockPanelRenderer = dockPanelRenderer;
        _this.statusBar = statusBar;
        _this.splitPositionHandler = splitPositionHandler;
        /**
         * The current state of the bottom panel.
         */
        _this.bottomPanelState = {
            loading: true,
            expansion: side_panel_handler_1.SidePanel.ExpansionState.collapsed,
            pendingUpdate: Promise.resolve()
        };
        _this.tracker = new widgets_1.FocusTracker();
        /**
         * A signal emitted whenever the `currentWidget` property is changed.
         */
        _this.currentChanged = new signaling_1.Signal(_this);
        /**
         * A signal emitted whenever the `activeWidget` property is changed.
         */
        _this.activeChanged = new signaling_1.Signal(_this);
        _this.addClass(APPLICATION_SHELL_CLASS);
        _this.id = 'theia-app-shell';
        // Merge the user-defined application options with the default options
        _this.options = {
            bottomPanel: __assign({}, ApplicationShell_1.DEFAULT_OPTIONS.bottomPanel, options.bottomPanel || {}),
            leftPanel: __assign({}, ApplicationShell_1.DEFAULT_OPTIONS.leftPanel, options.leftPanel || {}),
            rightPanel: __assign({}, ApplicationShell_1.DEFAULT_OPTIONS.rightPanel, options.rightPanel || {})
        };
        _this.mainPanel = _this.createMainPanel();
        _this.topPanel = _this.createTopPanel();
        _this.bottomPanel = _this.createBottomPanel();
        _this.leftPanelHandler = sidePanelHandlerFactory();
        _this.leftPanelHandler.create('left', _this.options.leftPanel);
        _this.rightPanelHandler = sidePanelHandlerFactory();
        _this.rightPanelHandler.create('right', _this.options.rightPanel);
        _this.layout = _this.createLayout();
        _this.tracker.currentChanged.connect(_this.onCurrentChanged, _this);
        _this.tracker.activeChanged.connect(_this.onActiveChanged, _this);
        return _this;
    }
    ApplicationShell_1 = ApplicationShell;
    ApplicationShell.prototype.onBeforeAttach = function (msg) {
        document.addEventListener('p-dragenter', this, true);
        document.addEventListener('p-dragover', this, true);
        document.addEventListener('p-dragleave', this, true);
        document.addEventListener('p-drop', this, true);
    };
    ApplicationShell.prototype.onAfterDetach = function (msg) {
        document.removeEventListener('p-dragenter', this, true);
        document.removeEventListener('p-dragover', this, true);
        document.removeEventListener('p-dragleave', this, true);
        document.removeEventListener('p-drop', this, true);
    };
    ApplicationShell.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'p-dragenter':
                this.onDragEnter(event);
                break;
            case 'p-dragover':
                this.onDragOver(event);
                break;
            case 'p-drop':
                this.onDrop(event);
                break;
            case 'p-dragleave':
                this.onDragLeave(event);
                break;
        }
    };
    ApplicationShell.prototype.onDragEnter = function (_a) {
        var mimeData = _a.mimeData;
        if (!this.dragState) {
            if (mimeData && mimeData.hasData('application/vnd.phosphor.widget-factory')) {
                // The drag contains a widget, so we'll track it and expand side panels as needed
                this.dragState = {
                    startTime: performance.now(),
                    leftExpanded: false,
                    rightExpanded: false,
                    bottomExpanded: false
                };
            }
        }
    };
    ApplicationShell.prototype.onDragOver = function (event) {
        var _this = this;
        var state = this.dragState;
        if (state) {
            state.lastDragOver = event;
            if (state.leaveTimeout) {
                window.clearTimeout(state.leaveTimeout);
                state.leaveTimeout = undefined;
            }
            var clientX = event.clientX, clientY = event.clientY;
            var _a = this.node, offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop, clientWidth = _a.clientWidth, clientHeight = _a.clientHeight;
            // Don't expand any side panels right after the drag has started
            var allowExpansion = performance.now() - state.startTime >= 500;
            var expLeft = allowExpansion && clientX >= offsetLeft
                && clientX <= offsetLeft + this.options.leftPanel.expandThreshold;
            var expRight = allowExpansion && clientX <= offsetLeft + clientWidth
                && clientX >= offsetLeft + clientWidth - this.options.rightPanel.expandThreshold;
            var expBottom = allowExpansion && !expLeft && !expRight && clientY <= offsetTop + clientHeight
                && clientY >= offsetTop + clientHeight - this.options.bottomPanel.expandThreshold;
            if (expLeft && !state.leftExpanded && this.leftPanelHandler.tabBar.currentTitle === null) {
                // The mouse cursor is moved close to the left border
                this.leftPanelHandler.expand();
                this.leftPanelHandler.state.pendingUpdate.then(function () { return _this.dispatchMouseMove(); });
                state.leftExpanded = true;
            }
            else if (!expLeft && state.leftExpanded) {
                // The mouse cursor is moved away from the left border
                this.leftPanelHandler.collapse();
                state.leftExpanded = false;
            }
            if (expRight && !state.rightExpanded && this.rightPanelHandler.tabBar.currentTitle === null) {
                // The mouse cursor is moved close to the right border
                this.rightPanelHandler.expand();
                this.rightPanelHandler.state.pendingUpdate.then(function () { return _this.dispatchMouseMove(); });
                state.rightExpanded = true;
            }
            else if (!expRight && state.rightExpanded) {
                // The mouse cursor is moved away from the right border
                this.rightPanelHandler.collapse();
                state.rightExpanded = false;
            }
            if (expBottom && !state.bottomExpanded && this.bottomPanel.isHidden) {
                // The mouse cursor is moved close to the bottom border
                this.expandBottomPanel();
                this.bottomPanelState.pendingUpdate.then(function () { return _this.dispatchMouseMove(); });
                state.bottomExpanded = true;
            }
            else if (!expBottom && state.bottomExpanded) {
                // The mouse cursor is moved away from the bottom border
                this.collapseBottomPanel();
                state.bottomExpanded = false;
            }
        }
    };
    /**
     * This method is called after a side panel has been expanded while dragging a widget. It fires
     * a `mousemove` event so that the drag overlay markers are updated correctly in all dock panels.
     */
    ApplicationShell.prototype.dispatchMouseMove = function () {
        if (this.dragState && this.dragState.lastDragOver) {
            var _a = this.dragState.lastDragOver, clientX = _a.clientX, clientY = _a.clientY;
            var event_1 = document.createEvent('MouseEvent');
            event_1.initMouseEvent('mousemove', true, true, window, 0, 0, 0, clientX, clientY, false, false, false, false, 0, null);
            document.dispatchEvent(event_1);
        }
    };
    ApplicationShell.prototype.onDrop = function (event) {
        var _this = this;
        var state = this.dragState;
        if (state) {
            if (state.leaveTimeout) {
                window.clearTimeout(state.leaveTimeout);
            }
            this.dragState = undefined;
            window.requestAnimationFrame(function () {
                // Clean up the side panel state in the next frame
                if (_this.leftPanelHandler.dockPanel.isEmpty) {
                    _this.leftPanelHandler.collapse();
                }
                if (_this.rightPanelHandler.dockPanel.isEmpty) {
                    _this.rightPanelHandler.collapse();
                }
                if (_this.bottomPanel.isEmpty) {
                    _this.collapseBottomPanel();
                }
            });
        }
    };
    ApplicationShell.prototype.onDragLeave = function (event) {
        var _this = this;
        var state = this.dragState;
        if (state) {
            state.lastDragOver = undefined;
            if (state.leaveTimeout) {
                window.clearTimeout(state.leaveTimeout);
            }
            state.leaveTimeout = window.setTimeout(function () {
                _this.dragState = undefined;
                if (state.leftExpanded || _this.leftPanelHandler.dockPanel.isEmpty) {
                    _this.leftPanelHandler.collapse();
                }
                if (state.rightExpanded || _this.rightPanelHandler.dockPanel.isEmpty) {
                    _this.rightPanelHandler.collapse();
                }
                if (state.bottomExpanded || _this.bottomPanel.isEmpty) {
                    _this.collapseBottomPanel();
                }
            }, 100);
        }
    };
    /**
     * Create the dock panel in the main shell area.
     */
    ApplicationShell.prototype.createMainPanel = function () {
        var dockPanel = new side_panel_handler_1.TheiaDockPanel({
            mode: 'multiple-document',
            renderer: this.dockPanelRenderer,
            spacing: 0
        });
        dockPanel.id = 'theia-main-content-panel';
        return dockPanel;
    };
    /**
     * Create the dock panel in the bottom shell area.
     */
    ApplicationShell.prototype.createBottomPanel = function () {
        var _this = this;
        var dockPanel = new side_panel_handler_1.TheiaDockPanel({
            mode: 'multiple-document',
            renderer: this.dockPanelRenderer,
            spacing: 0
        });
        dockPanel.id = 'theia-bottom-content-panel';
        dockPanel.widgetRemoved.connect(function (sender, widget) {
            if (dockPanel.isEmpty) {
                _this.collapseBottomPanel();
            }
        }, this);
        dockPanel.node.addEventListener('p-dragenter', function (event) {
            // Make sure that the main panel hides its overlay when the bottom panel is expanded
            _this.mainPanel.overlay.hide(0);
        });
        dockPanel.hide();
        return dockPanel;
    };
    /**
     * Create the top panel, which is used to hold the main menu.
     */
    ApplicationShell.prototype.createTopPanel = function () {
        var topPanel = new widgets_1.Panel();
        topPanel.id = 'theia-top-panel';
        return topPanel;
    };
    /**
     * Create a box layout to assemble the application shell layout.
     */
    ApplicationShell.prototype.createBoxLayout = function (widgets, stretch, options) {
        var boxLayout = new widgets_1.BoxLayout(options);
        for (var i = 0; i < widgets.length; i++) {
            if (stretch !== undefined && i < stretch.length) {
                widgets_1.BoxPanel.setStretch(widgets[i], stretch[i]);
            }
            boxLayout.addWidget(widgets[i]);
        }
        return boxLayout;
    };
    /**
     * Create a split layout to assemble the application shell layout.
     */
    ApplicationShell.prototype.createSplitLayout = function (widgets, stretch, options) {
        var optParam = { renderer: widgets_1.SplitPanel.defaultRenderer, };
        if (options) {
            optParam = __assign({}, optParam, options);
        }
        var splitLayout = new widgets_1.SplitLayout(optParam);
        for (var i = 0; i < widgets.length; i++) {
            if (stretch !== undefined && i < stretch.length) {
                widgets_1.SplitPanel.setStretch(widgets[i], stretch[i]);
            }
            splitLayout.addWidget(widgets[i]);
        }
        return splitLayout;
    };
    /**
     * Assemble the application shell layout. Override this method in order to change the arrangement
     * of the main area and the side panels.
     */
    ApplicationShell.prototype.createLayout = function () {
        var bottomSplitLayout = this.createSplitLayout([this.mainPanel, this.bottomPanel], [1, 0], { orientation: 'vertical', spacing: 2 });
        var panelForBottomArea = new widgets_1.SplitPanel({ layout: bottomSplitLayout });
        panelForBottomArea.id = 'theia-bottom-split-panel';
        var leftRightSplitLayout = this.createSplitLayout([this.leftPanelHandler.container, panelForBottomArea, this.rightPanelHandler.container], [0, 1, 0], { orientation: 'horizontal', spacing: 2 });
        var panelForSideAreas = new widgets_1.SplitPanel({ layout: leftRightSplitLayout });
        panelForSideAreas.id = 'theia-left-right-split-panel';
        return this.createBoxLayout([this.topPanel, panelForSideAreas, this.statusBar], [0, 1, 0], { direction: 'top-to-bottom', spacing: 0 });
    };
    Object.defineProperty(ApplicationShell.prototype, "loading", {
        /**
         * Change the state of the application to currently loading (`true`) or ready (`false`).
         * This has an impact on the behavior of certain operations, e.g. animations are disabled
         * while loading.
         */
        set: function (value) {
            this.bottomPanelState.loading = value;
            this.leftPanelHandler.state.loading = value;
            this.rightPanelHandler.state.loading = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an object that describes the current shell layout. This object may contain references
     * to widgets; these need to be transformed before the layout can be serialized.
     */
    ApplicationShell.prototype.getLayoutData = function () {
        return {
            mainPanel: this.mainPanel.saveLayout(),
            bottomPanel: {
                config: this.bottomPanel.saveLayout(),
                size: this.bottomPanel.isVisible ? this.getBottomPanelSize() : this.bottomPanelState.lastPanelSize,
                expanded: this.isExpanded('bottom')
            },
            leftPanel: this.leftPanelHandler.getLayoutData(),
            rightPanel: this.rightPanelHandler.getLayoutData(),
            statusBar: this.statusBar.getLayoutData()
        };
    };
    /**
     * Compute the current height of the bottom panel. This implementation assumes that the container
     * of the bottom panel is a `SplitPanel`.
     */
    ApplicationShell.prototype.getBottomPanelSize = function () {
        var parent = this.bottomPanel.parent;
        if (parent instanceof widgets_1.SplitPanel && parent.isVisible) {
            var index = parent.widgets.indexOf(this.bottomPanel) - 1;
            if (index >= 0) {
                var handle = parent.handles[index];
                if (!handle.classList.contains('p-mod-hidden')) {
                    var parentHeight = parent.node.clientHeight;
                    return parentHeight - handle.offsetTop;
                }
            }
        }
    };
    /**
     * Determine the default size to apply when the bottom panel is expanded for the first time.
     */
    ApplicationShell.prototype.getDefaultBottomPanelSize = function () {
        var parent = this.bottomPanel.parent;
        if (parent && parent.isVisible) {
            return parent.node.clientHeight * this.options.bottomPanel.initialSizeRatio;
        }
    };
    /**
     * Apply a shell layout that has been previously created with `getLayoutData`.
     */
    ApplicationShell.prototype.setLayoutData = function (_a) {
        var mainPanel = _a.mainPanel, bottomPanel = _a.bottomPanel, leftPanel = _a.leftPanel, rightPanel = _a.rightPanel, statusBar = _a.statusBar;
        if (mainPanel) {
            this.mainPanel.restoreLayout(mainPanel);
            this.registerWithFocusTracker(mainPanel.main);
        }
        if (bottomPanel) {
            if (bottomPanel.config) {
                this.bottomPanel.restoreLayout(bottomPanel.config);
                this.registerWithFocusTracker(bottomPanel.config.main);
            }
            if (bottomPanel.size) {
                this.bottomPanelState.lastPanelSize = bottomPanel.size;
            }
            if (bottomPanel.expanded) {
                this.expandBottomPanel();
            }
            else {
                this.collapseBottomPanel();
            }
        }
        if (leftPanel) {
            this.leftPanelHandler.setLayoutData(leftPanel);
            this.registerWithFocusTracker(leftPanel);
        }
        if (rightPanel) {
            this.rightPanelHandler.setLayoutData(rightPanel);
            this.registerWithFocusTracker(rightPanel);
        }
        if (statusBar) {
            this.statusBar.setLayoutData(statusBar);
        }
    };
    /**
     * Modify the height of the bottom panel. This implementation assumes that the container of the
     * bottom panel is a `SplitPanel`.
     */
    ApplicationShell.prototype.setBottomPanelSize = function (size) {
        var options = {
            side: 'bottom',
            duration: this.bottomPanelState.loading ? 0 : this.options.bottomPanel.expandDuration,
            referenceWidget: this.bottomPanel
        };
        var promise = this.splitPositionHandler.setSidePanelSize(this.bottomPanel, size, options);
        var result = new Promise(function (resolve) {
            // Resolve the resulting promise in any case, regardless of whether resizing was successful
            promise.then(function () { return resolve(); }, function () { return resolve(); });
        });
        this.bottomPanelState.pendingUpdate = this.bottomPanelState.pendingUpdate.then(function () { return result; });
        return result;
    };
    Object.defineProperty(ApplicationShell.prototype, "pendingUpdates", {
        /**
         * A promise that is resolved when all currently pending updates are done.
         */
        get: function () {
            return Promise.all([
                this.bottomPanelState.pendingUpdate,
                this.leftPanelHandler.state.pendingUpdate,
                this.rightPanelHandler.state.pendingUpdate
            ]);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Track all widgets that are referenced by the given layout data.
     */
    ApplicationShell.prototype.registerWithFocusTracker = function (data) {
        if (data) {
            if (data.type === 'tab-area') {
                try {
                    for (var _a = __values(data.widgets), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var widget = _b.value;
                        if (widget) {
                            this.track(widget);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else if (data.type === 'split-area') {
                try {
                    for (var _d = __values(data.children), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var child = _e.value;
                        this.registerWithFocusTracker(child);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            else if (data.type === 'sidepanel' && data.items) {
                try {
                    for (var _g = __values(data.items), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var item = _h.value;
                        if (item.widget) {
                            this.track(item.widget);
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_j = _g.return)) _j.call(_g);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        var e_1, _c, e_2, _f, e_3, _j;
    };
    /**
     * Add a widget to the application shell. The given widget must have a unique `id` property,
     * which will be used as the DOM id.
     *
     * Widgets are removed from the shell by calling their `close` or `dispose` methods.
     *
     * Widgets added to the top area are not tracked regarding the _current_ and _active_ states.
     */
    ApplicationShell.prototype.addWidget = function (widget, options) {
        if (!widget.id) {
            console.error('Widgets added to the application shell must have a unique id property.');
            return;
        }
        switch (options.area) {
            case 'main':
                this.mainPanel.addWidget(widget, options);
                break;
            case 'top':
                this.topPanel.addWidget(widget);
                break;
            case 'bottom':
                this.bottomPanel.addWidget(widget, options);
                break;
            case 'left':
                this.leftPanelHandler.addWidget(widget, options);
                break;
            case 'right':
                this.rightPanelHandler.addWidget(widget, options);
                break;
            default:
                throw new Error('Illegal argument: ' + options.area);
        }
        if (options.area !== 'top') {
            this.track(widget);
        }
    };
    /**
     * The widgets contained in the given shell area.
     */
    ApplicationShell.prototype.getWidgets = function (area) {
        switch (area) {
            case 'main':
                return algorithm_1.toArray(this.mainPanel.widgets());
            case 'top':
                return algorithm_1.toArray(this.topPanel.widgets);
            case 'bottom':
                return algorithm_1.toArray(this.bottomPanel.widgets());
            case 'left':
                return algorithm_1.toArray(this.leftPanelHandler.dockPanel.widgets());
            case 'right':
                return algorithm_1.toArray(this.rightPanelHandler.dockPanel.widgets());
            default:
                throw new Error('Illegal argument: ' + area);
        }
    };
    Object.defineProperty(ApplicationShell.prototype, "currentWidget", {
        /**
         * The current widget in the application shell. The current widget is the last widget that
         * was active and not yet closed. See the remarks to `activeWidget` on what _active_ means.
         */
        get: function () {
            return this.tracker.currentWidget || undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ApplicationShell.prototype, "activeWidget", {
        /**
         * The active widget in the application shell. The active widget is the one that has focus
         * (either the widget itself or any of its contents).
         *
         * _Note:_ Focus is taken by a widget through the `onActivateRequest` method. It is up to the
         * widget implementation which DOM element will get the focus. The default implementation
         * does not take any focus; in that case the widget is never returned by this property.
         */
        get: function () {
            return this.tracker.activeWidget || undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle a change to the current widget.
     */
    ApplicationShell.prototype.onCurrentChanged = function (sender, args) {
        this.currentChanged.emit(args);
    };
    /**
     * Handle a change to the active widget.
     */
    ApplicationShell.prototype.onActiveChanged = function (sender, args) {
        var newValue = args.newValue, oldValue = args.oldValue;
        if (oldValue) {
            // Reset the z-index to the default
            this.setZIndex(oldValue.node, null);
        }
        if (newValue) {
            // Reveal the title of the active widget in its tab bar
            var tabBar = this.getTabBarFor(newValue);
            if (tabBar instanceof tab_bars_1.ScrollableTabBar) {
                var index = tabBar.titles.indexOf(newValue.title);
                if (index >= 0) {
                    tabBar.revealTab(index);
                }
            }
            // Set the z-index so elements with `position: fixed` contained in the active widget are displayed correctly
            this.setZIndex(newValue.node, '1');
        }
        this.activeChanged.emit(args);
    };
    /**
     * Set the z-index of the given element and its ancestors to the value `z`.
     */
    ApplicationShell.prototype.setZIndex = function (element, z) {
        element.style.zIndex = z;
        var parent = element.parentElement;
        if (parent && parent !== this.node) {
            this.setZIndex(parent, z);
        }
    };
    /**
     * Track the given widget so it is considered in the `current` and `active` state of the shell.
     */
    ApplicationShell.prototype.track = function (widget) {
        this.tracker.add(widget);
        saveable_1.Saveable.apply(widget);
    };
    /**
     * Activate a widget in the application shell. This makes the widget visible and usually
     * also assigns focus to it.
     *
     * _Note:_ Focus is taken by a widget through the `onActivateRequest` method. It is up to the
     * widget implementation which DOM element will get the focus. The default implementation
     * does not take any focus.
     *
     * @returns the activated widget if it was found
     */
    ApplicationShell.prototype.activateWidget = function (id) {
        var widget = algorithm_1.find(this.mainPanel.widgets(), function (w) { return w.id === id; });
        if (widget) {
            this.mainPanel.activateWidget(widget);
            return widget;
        }
        widget = algorithm_1.find(this.bottomPanel.widgets(), function (w) { return w.id === id; });
        if (widget) {
            this.expandBottomPanel();
            this.bottomPanel.activateWidget(widget);
            return widget;
        }
        widget = this.leftPanelHandler.activate(id);
        if (widget) {
            return widget;
        }
        widget = this.rightPanelHandler.activate(id);
        if (widget) {
            return widget;
        }
    };
    /**
     * Reveal a widget in the application shell. This makes the widget visible,
     * but does not activate it.
     *
     * @returns the revealed widget if it was found
     */
    ApplicationShell.prototype.revealWidget = function (id) {
        var widget = algorithm_1.find(this.mainPanel.widgets(), function (w) { return w.id === id; });
        if (!widget) {
            widget = algorithm_1.find(this.bottomPanel.widgets(), function (w) { return w.id === id; });
            if (widget) {
                this.expandBottomPanel();
            }
        }
        if (widget) {
            var tabBar = this.getTabBarFor(widget);
            if (tabBar) {
                tabBar.currentTitle = widget.title;
            }
            return widget;
        }
        widget = this.leftPanelHandler.expand(id);
        if (widget) {
            return widget;
        }
        widget = this.rightPanelHandler.expand(id);
        if (widget) {
            return widget;
        }
    };
    /**
     * Expand the named side panel area. This makes sure that the panel is visible, even if there
     * are no widgets in it. If the panel is already visible, nothing happens. If the panel is currently
     * collapsed (see `collapsePanel`) and it contains widgets, the widgets are revealed that were
     * visible before it was collapsed.
     */
    ApplicationShell.prototype.expandPanel = function (area) {
        switch (area) {
            case 'bottom':
                this.expandBottomPanel();
                break;
            case 'left':
                this.leftPanelHandler.expand();
                break;
            case 'right':
                this.rightPanelHandler.expand();
                break;
            default:
                throw new Error('Area cannot be expanded: ' + area);
        }
    };
    /**
     * Expand the bottom panel. See `expandPanel` regarding the exact behavior.
     */
    ApplicationShell.prototype.expandBottomPanel = function () {
        var _this = this;
        var bottomPanel = this.bottomPanel;
        if (bottomPanel.isHidden) {
            var relativeSizes = void 0;
            var parent_1 = bottomPanel.parent;
            if (parent_1 instanceof widgets_1.SplitPanel) {
                relativeSizes = parent_1.relativeSizes();
            }
            bottomPanel.show();
            if (relativeSizes && parent_1 instanceof widgets_1.SplitPanel) {
                // Make sure that the expansion animation starts at the smallest possible size
                parent_1.setRelativeSizes(relativeSizes);
            }
            var size = void 0;
            if (bottomPanel.isEmpty) {
                bottomPanel.node.style.minHeight = '0';
                size = this.options.bottomPanel.emptySize;
            }
            else if (this.bottomPanelState.lastPanelSize) {
                size = this.bottomPanelState.lastPanelSize;
            }
            else {
                size = this.getDefaultBottomPanelSize();
            }
            if (size) {
                this.bottomPanelState.expansion = side_panel_handler_1.SidePanel.ExpansionState.expanding;
                this.setBottomPanelSize(size).then(function () {
                    if (_this.bottomPanelState.expansion === side_panel_handler_1.SidePanel.ExpansionState.expanding) {
                        _this.bottomPanelState.expansion = side_panel_handler_1.SidePanel.ExpansionState.expanded;
                    }
                });
            }
            else {
                this.bottomPanelState.expansion = side_panel_handler_1.SidePanel.ExpansionState.expanded;
            }
        }
    };
    /**
     * Collapse the named side panel area. This makes sure that the panel is hidden,
     * increasing the space that is available for other shell areas.
     */
    ApplicationShell.prototype.collapsePanel = function (area) {
        switch (area) {
            case 'bottom':
                this.collapseBottomPanel();
                break;
            case 'left':
                this.leftPanelHandler.collapse();
                break;
            case 'right':
                this.rightPanelHandler.collapse();
                break;
            default:
                throw new Error('Area cannot be collapsed: ' + area);
        }
    };
    /**
     * Collapse the bottom panel. All contained widgets are hidden, but not closed.
     * They can be restored by calling `expandBottomPanel`.
     */
    ApplicationShell.prototype.collapseBottomPanel = function () {
        var bottomPanel = this.bottomPanel;
        if (!bottomPanel.isHidden) {
            if (this.bottomPanelState.expansion === side_panel_handler_1.SidePanel.ExpansionState.expanded) {
                var size = this.getBottomPanelSize();
                if (size) {
                    this.bottomPanelState.lastPanelSize = size;
                }
            }
            this.bottomPanelState.expansion = side_panel_handler_1.SidePanel.ExpansionState.collapsed;
            bottomPanel.hide();
        }
    };
    /**
     * Check whether the named side panel area is expanded (returns `true`) or collapsed (returns `false`).
     */
    ApplicationShell.prototype.isExpanded = function (area) {
        switch (area) {
            case 'bottom':
                return this.bottomPanelState.expansion === side_panel_handler_1.SidePanel.ExpansionState.expanded;
            case 'left':
                return this.leftPanelHandler.state.expansion === side_panel_handler_1.SidePanel.ExpansionState.expanded;
            case 'right':
                return this.rightPanelHandler.state.expansion === side_panel_handler_1.SidePanel.ExpansionState.expanded;
            default:
                return true;
        }
    };
    /**
     * Close all tabs or a selection of tabs in a specific part of the application shell.
     *
     * @param tabBarOrArea
     *      Either the name of a shell area or a `TabBar` that is contained in such an area.
     * @param filter
     *      If undefined, all tabs are closed; otherwise only those tabs that match the filter are closed.
     */
    ApplicationShell.prototype.closeTabs = function (tabBarOrArea, filter) {
        var _this = this;
        if (tabBarOrArea === 'main') {
            this.mainAreaTabBars.forEach(function (tb) { return _this.closeTabs(tb, filter); });
        }
        else if (tabBarOrArea === 'bottom') {
            this.bottomAreaTabBars.forEach(function (tb) { return _this.closeTabs(tb, filter); });
        }
        else if (typeof tabBarOrArea === 'string') {
            var tabBar = this.getTabBarFor(tabBarOrArea);
            if (tabBar) {
                this.closeTabs(tabBar, filter);
            }
        }
        else if (tabBarOrArea) {
            var titles = algorithm_1.toArray(tabBarOrArea.titles);
            for (var i = 0; i < titles.length; i++) {
                if (filter === undefined || filter(titles[i], i)) {
                    titles[i].owner.close();
                }
            }
        }
    };
    Object.defineProperty(ApplicationShell.prototype, "currentTabArea", {
        /**
         * The shell area name of the currently active tab, or undefined.
         */
        get: function () {
            var currentWidget = this.currentWidget;
            if (currentWidget) {
                return this.getAreaFor(currentWidget);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Determine the name of the shell area where the given widget resides. The result is
     * undefined if the widget does not reside directly in the shell.
     */
    ApplicationShell.prototype.getAreaFor = function (widget) {
        var title = widget.title;
        var mainPanelTabBar = algorithm_1.find(this.mainPanel.tabBars(), function (bar) { return algorithm_1.ArrayExt.firstIndexOf(bar.titles, title) > -1; });
        if (mainPanelTabBar) {
            return 'main';
        }
        var bottomPanelTabBar = algorithm_1.find(this.bottomPanel.tabBars(), function (bar) { return algorithm_1.ArrayExt.firstIndexOf(bar.titles, title) > -1; });
        if (bottomPanelTabBar) {
            return 'bottom';
        }
        if (algorithm_1.ArrayExt.firstIndexOf(this.leftPanelHandler.tabBar.titles, title) > -1) {
            return 'left';
        }
        if (algorithm_1.ArrayExt.firstIndexOf(this.rightPanelHandler.tabBar.titles, title) > -1) {
            return 'right';
        }
    };
    Object.defineProperty(ApplicationShell.prototype, "currentTabBar", {
        /**
         * Return the tab bar that has the currently active widget, or undefined.
         */
        get: function () {
            var currentWidget = this.currentWidget;
            if (currentWidget) {
                return this.getTabBarFor(currentWidget);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return the tab bar in the given shell area, or the tab bar that has the given widget, or undefined.
     */
    ApplicationShell.prototype.getTabBarFor = function (widgetOrArea) {
        if (typeof widgetOrArea === 'string') {
            switch (widgetOrArea) {
                case 'main':
                    return this.mainPanel.tabBars().next();
                case 'bottom':
                    return this.bottomPanel.tabBars().next();
                case 'left':
                    return this.leftPanelHandler.tabBar;
                case 'right':
                    return this.rightPanelHandler.tabBar;
                default:
                    throw new Error('Illegal argument: ' + widgetOrArea);
            }
        }
        else if (widgetOrArea && widgetOrArea.isAttached) {
            var widgetTitle_1 = widgetOrArea.title;
            var mainPanelTabBar = algorithm_1.find(this.mainPanel.tabBars(), function (bar) { return algorithm_1.ArrayExt.firstIndexOf(bar.titles, widgetTitle_1) > -1; });
            if (mainPanelTabBar) {
                return mainPanelTabBar;
            }
            var bottomPanelTabBar = algorithm_1.find(this.bottomPanel.tabBars(), function (bar) { return algorithm_1.ArrayExt.firstIndexOf(bar.titles, widgetTitle_1) > -1; });
            if (bottomPanelTabBar) {
                return bottomPanelTabBar;
            }
            var leftPanelTabBar = this.leftPanelHandler.tabBar;
            if (algorithm_1.ArrayExt.firstIndexOf(leftPanelTabBar.titles, widgetTitle_1) > -1) {
                return leftPanelTabBar;
            }
            var rightPanelTabBar = this.rightPanelHandler.tabBar;
            if (algorithm_1.ArrayExt.firstIndexOf(rightPanelTabBar.titles, widgetTitle_1) > -1) {
                return rightPanelTabBar;
            }
        }
    };
    Object.defineProperty(ApplicationShell.prototype, "mainAreaTabBars", {
        /**
         * The tab bars contained in the main shell area. If there is no widget in the main area, the
         * returned array is empty.
         */
        get: function () {
            return algorithm_1.toArray(this.mainPanel.tabBars());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ApplicationShell.prototype, "bottomAreaTabBars", {
        /**
         * The tab bars contained in the bottom shell area. If there is no widget in the bottom area,
         * the returned array is empty.
         */
        get: function () {
            return algorithm_1.toArray(this.bottomPanel.tabBars());
        },
        enumerable: true,
        configurable: true
    });
    /*
     * Activate the next tab in the current tab bar.
     */
    ApplicationShell.prototype.activateNextTab = function () {
        var current = this.currentTabBar;
        if (current) {
            var ci = current.currentIndex;
            if (ci !== -1) {
                if (ci < current.titles.length - 1) {
                    current.currentIndex += 1;
                    if (current.currentTitle) {
                        current.currentTitle.owner.activate();
                    }
                }
                else if (ci === current.titles.length - 1) {
                    var nextBar = this.nextTabBar(current);
                    nextBar.currentIndex = 0;
                    if (nextBar.currentTitle) {
                        nextBar.currentTitle.owner.activate();
                    }
                }
            }
        }
    };
    /**
     * Return the tab bar next to the given tab bar; return the given tab bar if there is no adjacent one.
     */
    ApplicationShell.prototype.nextTabBar = function (current) {
        var bars = algorithm_1.toArray(this.bottomPanel.tabBars());
        var len = bars.length;
        var ci = algorithm_1.ArrayExt.firstIndexOf(bars, current);
        if (ci < 0) {
            bars = algorithm_1.toArray(this.mainPanel.tabBars());
            len = bars.length;
            ci = algorithm_1.ArrayExt.firstIndexOf(bars, current);
        }
        if (ci >= 0 && ci < len - 1) {
            return bars[ci + 1];
        }
        else if (ci >= 0 && ci === len - 1) {
            return bars[0];
        }
        else {
            return current;
        }
    };
    /*
     * Activate the previous tab in the current tab bar.
     */
    ApplicationShell.prototype.activatePreviousTab = function () {
        var current = this.currentTabBar;
        if (current) {
            var ci = current.currentIndex;
            if (ci !== -1) {
                if (ci > 0) {
                    current.currentIndex -= 1;
                    if (current.currentTitle) {
                        current.currentTitle.owner.activate();
                    }
                }
                else if (ci === 0) {
                    var prevBar = this.previousTabBar(current);
                    var len = prevBar.titles.length;
                    prevBar.currentIndex = len - 1;
                    if (prevBar.currentTitle) {
                        prevBar.currentTitle.owner.activate();
                    }
                }
            }
        }
    };
    /**
     * Return the tab bar previous to the given tab bar; return the given tab bar if there is no adjacent one.
     */
    ApplicationShell.prototype.previousTabBar = function (current) {
        var bars = algorithm_1.toArray(this.mainPanel.tabBars());
        var len = bars.length;
        var ci = algorithm_1.ArrayExt.firstIndexOf(bars, current);
        if (ci > 0) {
            return bars[ci - 1];
        }
        else if (ci === 0) {
            return bars[len - 1];
        }
        else {
            return current;
        }
    };
    /**
     * Test whether the current widget is dirty.
     */
    ApplicationShell.prototype.canSave = function () {
        return saveable_1.Saveable.isDirty(this.currentWidget);
    };
    /**
     * Save the current widget if it is dirty.
     */
    ApplicationShell.prototype.save = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, saveable_1.Saveable.save(this.currentWidget)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Test whether there is a dirty widget.
     */
    ApplicationShell.prototype.canSaveAll = function () {
        return this.tracker.widgets.some(saveable_1.Saveable.isDirty);
    };
    /**
     * Save all dirty widgets.
     */
    ApplicationShell.prototype.saveAll = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(this.tracker.widgets.map(saveable_1.Saveable.save))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    ApplicationShell = ApplicationShell_1 = __decorate([
        inversify_1.injectable(),
        __param(0, inversify_1.inject(DockPanelRenderer)),
        __param(1, inversify_1.inject(status_bar_1.StatusBarImpl)),
        __param(2, inversify_1.inject(side_panel_handler_1.SidePanelHandlerFactory)),
        __param(3, inversify_1.inject(split_panels_1.SplitPositionHandler)),
        __param(4, inversify_1.inject(exports.ApplicationShellOptions)), __param(4, inversify_1.optional()),
        __metadata("design:paramtypes", [DockPanelRenderer,
            status_bar_1.StatusBarImpl, Function, split_panels_1.SplitPositionHandler, Object])
    ], ApplicationShell);
    return ApplicationShell;
    var ApplicationShell_1;
}(widgets_1.Widget));
exports.ApplicationShell = ApplicationShell;
/**
 * The namespace for `ApplicationShell` class statics.
 */
(function (ApplicationShell) {
    /**
     * The _side areas_ are those shell areas that can be collapsed and expanded,
     * i.e. `left`, `right`, and `bottom`.
     */
    function isSideArea(area) {
        return area === 'left' || area === 'right' || area === 'bottom';
    }
    ApplicationShell.isSideArea = isSideArea;
    /**
     * The default values for application shell options.
     */
    ApplicationShell.DEFAULT_OPTIONS = Object.freeze({
        bottomPanel: Object.freeze({
            emptySize: 140,
            expandThreshold: 160,
            expandDuration: 150,
            initialSizeRatio: 0.382
        }),
        leftPanel: Object.freeze({
            emptySize: 140,
            expandThreshold: 140,
            expandDuration: 150,
            initialSizeRatio: 0.191
        }),
        rightPanel: Object.freeze({
            emptySize: 140,
            expandThreshold: 140,
            expandDuration: 150,
            initialSizeRatio: 0.191
        })
    });
})(ApplicationShell = exports.ApplicationShell || (exports.ApplicationShell = {}));
exports.ApplicationShell = ApplicationShell;
//# sourceMappingURL=application-shell.js.map