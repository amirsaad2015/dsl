import { MergeConflict } from "./merge-conflict";
export declare class MergeConflictsParser {
    private parser;
    constructor();
    parse(text: string): MergeConflict[];
    private init();
    private lineToRange(input);
    private addLineToRange(input, range);
}
export declare namespace MergeConflictsParser {
    class Context {
        new: MergeConflict;
        all: MergeConflict[];
    }
    interface Input {
        line: number;
        text: string;
    }
    class StateMachine<C extends object> {
        protected context: C;
        current: State<C>;
        readonly states: State<C>[];
        constructor(context: C);
        reset(context: C): void;
        read(input: Input): void;
        addState(id: string): State<C>;
    }
    class State<C> {
        readonly id: string;
        onEnter?: (input: Input, context: C) => void;
        readonly conditionalNext: {
            to: State<C>;
            condition: (input: Input, context: C) => boolean;
        }[];
        immediateNext: State<C> | undefined;
        constructor(id: string);
        findNext(input: Input, context: C): State<C> | undefined;
        to(next: State<C>, condition?: (input: Input, context: C) => boolean): void;
    }
}
