"use strict";
/*
 * Copyright (C) 2018 TypeFox and others.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License'); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var browser_1 = require("@theia/languages/lib/browser");
var MergeConflictResolver = /** @class */ (function () {
    function MergeConflictResolver(workspace) {
        var _this = this;
        this.workspace = workspace;
        this.acceptCurrent = {
            execute: function (args) { return _this.doAcceptCurrent(args); }
        };
        this.acceptIncoming = {
            execute: function (args) { return _this.doAcceptIncoming(args); }
        };
        this.acceptBoth = {
            execute: function (args) { return _this.doAcceptBoth(args); }
        };
    }
    MergeConflictResolver.prototype.doAcceptCurrent = function (argument) {
        this.doAccept(argument, function (textOfRange, conflict) {
            return textOfRange(conflict.current.content);
        });
    };
    MergeConflictResolver.prototype.doAcceptIncoming = function (argument) {
        this.doAccept(argument, function (textOfRange, conflict) {
            return textOfRange(conflict.incoming.content);
        });
    };
    MergeConflictResolver.prototype.doAcceptBoth = function (argument) {
        this.doAccept(argument, function (textOfRange, conflict) {
            var currentText = textOfRange(conflict.current.content);
            var incomingText = textOfRange(conflict.incoming.content);
            return currentText + "\n" + incomingText;
        });
    };
    MergeConflictResolver.prototype.doAccept = function (argument, newTextFn) {
        var _this = this;
        var uri = argument.uri, conflict = argument.conflict;
        var document = this.workspace.textDocuments.find(function (d) { return d.uri === uri; });
        if (document) {
            var newText = newTextFn(function (range) { return _this.getTextRange(range, document); }, conflict);
            this.workspace.applyEdit({
                documentChanges: [browser_1.TextDocumentEdit.create(document, [browser_1.TextEdit.replace(conflict.total, newText)])]
            });
        }
    };
    MergeConflictResolver.prototype.getTextRange = function (range, document) {
        var start = document.offsetAt(range.start);
        var end = document.offsetAt(range.end);
        var text = document.getText().substring(start, end);
        return text;
    };
    MergeConflictResolver = __decorate([
        inversify_1.injectable(),
        __param(0, inversify_1.inject(browser_1.Workspace)),
        __metadata("design:paramtypes", [Object])
    ], MergeConflictResolver);
    return MergeConflictResolver;
}());
exports.MergeConflictResolver = MergeConflictResolver;
//# sourceMappingURL=merge-conflict-resolver.js.map