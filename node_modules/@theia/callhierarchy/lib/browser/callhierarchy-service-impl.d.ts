import { ILanguageClient } from '@theia/languages/lib/common/languageclient-services';
import { LanguageClientProvider } from '@theia/languages/lib/browser/language-client-provider';
import { SymbolInformation, Location } from 'vscode-languageserver-types';
import { Definition, Caller } from './callhierarchy';
import { CallHierarchyService } from './callhierarchy-service';
import { ILogger, Disposable } from "@theia/core";
import { MonacoTextModelService } from "@theia/monaco/lib/browser/monaco-text-model-service";
export declare class CallHierarchyContext {
    readonly languageClient: ILanguageClient;
    readonly textModelService: MonacoTextModelService;
    readonly logger: ILogger;
    readonly symbolCache: Map<string, SymbolInformation[]>;
    readonly disposables: Disposable[];
    constructor(languageClient: ILanguageClient, textModelService: MonacoTextModelService, logger: ILogger);
    getAllSymbols(uri: string): Promise<SymbolInformation[]>;
    getEditorModelReference(uri: string): Promise<any>;
    getDefinitionLocation(location: Location): Promise<Location | undefined>;
    getCallerReferences(definition: Location): Promise<Location[]>;
    dispose(): void;
}
export declare abstract class AbstractDefaultCallHierarchyService implements CallHierarchyService {
    readonly languageClientProvider: LanguageClientProvider;
    readonly logger: ILogger;
    readonly textModelService: MonacoTextModelService;
    readonly abstract languageId: string;
    /**
     * Returns root definition of caller hierarchy.
     */
    getRootDefinition(location: Location): Promise<Definition | undefined>;
    /**
     * Returns next level of caller definitions.
     */
    getCallers(definition: Definition): Promise<Caller[] | undefined>;
    protected withContext<T>(lambda: (context: CallHierarchyContext) => Promise<T>): Promise<T | undefined>;
    protected createContext(): Promise<CallHierarchyContext | undefined>;
    /**
     * Creates callers for given references and method symbols.
     */
    protected createCallers(callerReferences: Location[], context: CallHierarchyContext): Promise<Caller[]>;
    protected toCaller(callerDefinition: Definition, references: Location[]): Caller;
    protected toDefinition(symbol: SymbolInformation, context: CallHierarchyContext): Promise<Definition | undefined>;
    /**
     * Override this to configure the callables of your language.
     */
    protected isCallable(symbol: SymbolInformation): boolean;
    /**
     * Finds the symbol that encloses the definition range of the root element
     *
     * As symbols can be nested, we are looking for the one with the smallest region.
     * As we only check regions that contain the definition, that is the one with the
     * latest start position.
     */
    protected getEnclosingRootSymbol(definition: Location, context: CallHierarchyContext): Promise<SymbolInformation | undefined>;
    /**
     * Finds the symbol that encloses the reference range of a caller
     */
    protected getEnclosingCallerSymbol(reference: Location, context: CallHierarchyContext): Promise<SymbolInformation | undefined>;
    /**
     * Finds the location of its name within a symbol's location.
     */
    protected getSymbolNameLocation(symbol: SymbolInformation, context: CallHierarchyContext): Promise<Location | undefined>;
}
